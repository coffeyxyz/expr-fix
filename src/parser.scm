;;;; parser.scm - Mathematical expression parser.

(declare (unit parser))

;; Convert a list of tokens into a parse tree.
(define (parse-expr fix tokens)
  (define (prefix tokens)
    (make-tree (let ((token (car tokens)))
                 (set! (car tokens) #f)
                 (token-value token))
               (if (token-operator? (cadr tokens))
                   (prefix (cdr tokens))
                   (let ((token (cadr tokens)))
                     (set! (cadr tokens) #f)
                     (make-tree (token-value token))))
               (let loop ((i 2))
                 (if (list-ref tokens i)
                     (if (token-operator? (list-ref tokens i))
                         (prefix (list-tail tokens i))
                         (let ((token (list-ref tokens i)))
                           (set! (list-ref tokens i) #f)
                           (make-tree (token-value token))))
                     (loop (+ i 1))))))

  ;;(define (infix tokens)
  ;;  )

  ;; TODO Fix this! I was too eager to get coding and didn't think this the full
  ;; way through. This works for expressions like "1 2 +", "1 2 * 3 4 / +", and
  ;; "1 2 + 3 +", but not "1 2 3 4 + + +". Just going to use a stack instead of
  ;; this two subtree thing.
  (define (postfix tokens)
    (define left #f)
    (define right #f)
    (define subtree1 #f)
    (define subtree2 #f)
    (let loop ((tokens tokens))
      (unless (null? tokens)
        (let ((token (car tokens)))
          (cond ((and subtree1 subtree2)
                 (begin (set! subtree1 (make-tree (token-value token)
                                                  subtree1 subtree2))
                        (set! subtree2 #f)))
                ((and subtree1 left right)
                 (begin (set! subtree2 (make-tree (token-value token)
                                                  left right))
                        (set! left #f)
                        (set! right #f)))
                ((and subtree1 left (token-operator? token))
                 (begin (set! subtree1 (make-tree (token-value token)
                                                  subtree1 left))
                        (set! left #f)))
                ((not left) (set! left (make-tree (token-value token))))
                ((not right) (set! right (make-tree (token-value token))))
                (else (begin (set! subtree1 (make-tree (token-value token)
                                                       left right))
                             (set! left #f)
                             (set! right #f)))))
        (loop (cdr tokens)))
      subtree1))

  (if (and (= (length tokens) 1)
           (eq? (token-type (car tokens)) 'number))
      (make-tree (token-value (car tokens)))
      (case fix
        ((prefix) (prefix tokens))
        ;;((infix) (infix tokens))
        ((postfix) (postfix tokens)))))
